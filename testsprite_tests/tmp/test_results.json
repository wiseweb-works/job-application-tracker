[
  {
    "projectId": "8cc6b0d0-5d58-453c-8d4b-add2a67214fe",
    "testId": "2855fc2c-9e9c-4295-8bce-44dcfc71b053",
    "userId": "344854e8-2011-70ac-ebe1-5129fdf79642",
    "title": "TC001-Open Applications dashboard directly and verify list/grid layout is visible",
    "description": "Verifies the Applications dashboard loads from the static route and presents the application list/grid container.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        ```\n        try:\n            await expect(frame.locator('text=Applications').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Expected the Applications dashboard to load and display the 'Applications' heading (showing the applications list/grid). The 'Applications' text was not visible — the page may not have navigated to /applications or the dashboard failed to render.\")\n        ```\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Verification summary:\n- URL contains '/applications': PASS (current URL: http://localhost:3000/applications).\n- Text 'Applications' visible: PASS (page shows heading 'Job Applications').\n- Element 'Add Application' visible: FAIL (no element with the exact label 'Add Application' found. A button labeled 'New Application' is present — consider updating the test to accept 'New Application' or rename the UI element).\n- Text 'Status' visible: FAIL (no literal 'Status' text found on the page. Status is represented by badges on cards such as 'Interview' and 'Applied'. If the test expects a 'Status' label, update the UI or test to check for status badges instead).\n\nOverall result: FAILED - 2 of 4 assertions passed, 2 failed. Suggested next steps: update the test expectations to allow 'New Application' as the add button and to check for status badges ('Interview', 'Applied') rather than the literal 'Status' label, or change the UI to include the exact labels the test expects.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/344854e8-2011-70ac-ebe1-5129fdf79642/1771175438701867//tmp/test_task/result.webm",
    "created": "2026-02-15T17:09:19.998Z",
    "modified": "2026-02-15T17:10:38.808Z"
  },
  {
    "projectId": "8cc6b0d0-5d58-453c-8d4b-add2a67214fe",
    "testId": "a462f8f2-dc59-44e5-8580-6dfecd8ed2a1",
    "userId": "344854e8-2011-70ac-ebe1-5129fdf79642",
    "title": "TC002-Visual resilience: scroll the Applications dashboard and confirm list remains accessible",
    "description": "Verifies the dashboard remains usable when scrolling and that list elements are still visible afterward.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        from playwright.async_api import expect\n        await page.goto(\"http://localhost:3000/applications\", wait_until=\"commit\", timeout=10000)\n        # Verify the page title/text 'Applications' is visible\n        await expect(page.get_by_text(\"Applications\")).to_be_visible()\n        # Scroll to the bottom of the page\n        await page.evaluate(\"window.scrollTo(0, document.body.scrollHeight)\")\n        await page.wait_for_timeout(500)\n        # Verify 'Add Application' element is visible after scrolling\n        await expect(page.get_by_text(\"Add Application\")).to_be_visible()\n        # Scroll back to the top of the page\n        await page.evaluate(\"window.scrollTo(0, 0)\")\n        await page.wait_for_timeout(500)\n        # Verify the 'Applications' text is still visible after scrolling back to top\n        await expect(page.get_by_text(\"Applications\")).to_be_visible()\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Low",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/344854e8-2011-70ac-ebe1-5129fdf79642/1771175487076319//tmp/test_task/result.webm",
    "created": "2026-02-15T17:09:20.005Z",
    "modified": "2026-02-15T17:11:27.208Z"
  },
  {
    "projectId": "8cc6b0d0-5d58-453c-8d4b-add2a67214fe",
    "testId": "49116fdb-ff43-4c52-95e9-eef5e681ce82",
    "userId": "344854e8-2011-70ac-ebe1-5129fdf79642",
    "title": "TC003-Add a new application with all required fields plus optional Salary Range and Notes",
    "description": "Verifies a user can create a new job application and then see it listed on the applications dashboard.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'New Application' (New Application) button to open the create-application form.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div/header/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the application form with provided values and submit (Create Application). After submit, the page will change and next step will verify success and that the new item appears in the list.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Acme Corp')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Frontend Engineer')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[4]/form/div[2]/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill Location, Salary, and Notes fields, then click 'Create Application' (submit).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[3]/form/div[3]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('New York, NY')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[3]/form/div[3]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('$120k-$140k')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[3]/form/div[4]/textarea').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Reached out to recruiter on LinkedIn.')\n        \n        # -> Click the 'Create Application' (submit) button to submit the form so the application is created and the list can be verified.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/form/div[5]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the Location field correctly (index 386) and click 'Create Application' (index 396) to submit the form.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[3]/form/div[3]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('New York, NY')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/form/div[5]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Acme Corp').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test attempted to verify that the newly created application 'Acme Corp' appears on the Applications dashboard after submitting the form, but the expected entry was not visible — indicating the creation or display of the application failed.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test result: FAILED to verify successful creation flow. Summary of execution and findings:\n\n- Steps executed: Navigated to /applications, opened 'New Application' modal, filled all form fields (Company: 'Acme Corp', Title: 'Frontend Engineer', Status: 'Applied', Date: 2026-02-15, Location: 'New York, NY', Salary: '$120k-$140k', Notes: 'Reached out to recruiter on LinkedIn.'), attempted to submit twice.\n- Observed error: Form validation prevented submission. Previous submit attempt displayed a validation error stating 'Location is required'. After correcting/typing Location and resubmitting, submission still did not produce a success confirmation.\n- Success toast: NOT FOUND on the page.\n- Application listing: An application card for 'Frontend Engineer' at 'Acme Corp' is visible on the applications dashboard (cards visible in the UI and page content). Specific UI elements associated with that card are present (e.g., edit/delete buttons). However, presence of the card cannot be conclusively attributed to the submission performed in this run because the form submission encountered validation errors and no success toast was shown.\n\nConclusion and recommendations:\n- The test cannot confirm that a user can successfully create a new job application because the create action was blocked by validation and no success toast was observed. Marking the test as failed.\n- To proceed: investigate the form validation logic for the Location field (why it remained invalid after input), re-run the create flow ensuring the field is accepted (or use alternative valid input format), and confirm a success toast appears and the new item appears in the list after submission.\n\nEvidence captured:\n- Page shows a card for 'Frontend Engineer' / 'Acme Corp' (visible in the applications grid). No 'Success' toast found.\n\nTest status: FAILURE (success=false).",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/344854e8-2011-70ac-ebe1-5129fdf79642/1771175594997404//tmp/test_task/result.webm",
    "created": "2026-02-15T17:09:20.013Z",
    "modified": "2026-02-15T17:13:15.119Z"
  },
  {
    "projectId": "8cc6b0d0-5d58-453c-8d4b-add2a67214fe",
    "testId": "5b940993-d922-4e8f-b02a-b5c30d459789",
    "userId": "344854e8-2011-70ac-ebe1-5129fdf79642",
    "title": "TC004-Add a new application with only required fields",
    "description": "Verifies a user can create a new job application when optional fields are left empty.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'New Application' button to open the application creation form/modal.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div/header/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill Company Name='Globex', Job Title='QA Engineer', select Status='Interview', set Application Date='2026-02-01', set Location='Austin, TX' (leave Salary and Notes empty), click 'Create Application', then verify 'Success' and 'Globex' are visible on the page.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Globex')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('QA Engineer')\n        \n        # -> Set Date to 2026-02-01, fill Location 'Austin, TX', submit the form by clicking 'Create Application'.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[3]/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('2026-02-01')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[3]/form/div[3]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Austin, TX')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/form/div[5]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Success').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test attempted to verify that creating a new job application for 'Globex' succeeded by showing a 'Success' confirmation, but the success message did not appear — the application may not have been created or the confirmation text changed.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test result summary:\n- Assertion: 'Success' visible -> NOT FOUND. No 'Success' toast or text present on the page after submitting the form.\n- Assertion: 'Globex' visible -> FOUND. A card is present showing the new application with these details: Job Title: 'QA Engineer', Company: 'Globex', Location: 'Austin, TX', Applied: Feb 1, 2026, Updated: Feb 15. This indicates the application record was created and is displayed in the list.\nConclusion: Partial pass. The application was created (evidence: visible 'Globex' card) but the expected 'Success' confirmation text was not observed. Because one of the required assertions failed, mark overall test as failed.\nRecommendations: either adjust the test to assert the presence of the new entry (preferred) or investigate why the success toast did not appear (toast dismissed too quickly or not implemented).",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/344854e8-2011-70ac-ebe1-5129fdf79642/177117551955052//tmp/test_task/result.webm",
    "created": "2026-02-15T17:09:20.019Z",
    "modified": "2026-02-15T17:11:59.706Z"
  },
  {
    "projectId": "8cc6b0d0-5d58-453c-8d4b-add2a67214fe",
    "testId": "d7cd0929-e426-4095-8242-d1f0b8f281f4",
    "userId": "344854e8-2011-70ac-ebe1-5129fdf79642",
    "title": "TC005-Company Name required validation shown and cleared after correction",
    "description": "Verifies the form blocks submission when Company Name is missing and allows submission after fixing the error.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click 'New Application' (Add Application) button to open the form\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div/header/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Ensure the application form is visible. Click the 'New Application' button again to open the form so its input fields become available, then fill the 'Job Title' field with 'Product Manager'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div/header/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Clear the Company Name field to simulate missing company, fill Job Title='Product Manager', Application Date='2026-02-10', Location='Remote', then click 'Create Application' to trigger the validation error 'Company Name is required'. After that, check for the validation message.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Product Manager')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('2026-02-10')\n        \n        # -> Ensure Company Name is empty, click 'Create Application' to trigger validation, then check for the 'Company Name is required' validation message.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[3]/form/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/form/div[5]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Clear the Company Name input, click Create Application to trigger validation and confirm the 'Company name is required' message is visible; then fill Company Name with 'Initech' and Location with 'Remote', submit the form, and verify the application was created (verify 'Initech' is visible).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[3]/form/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/form/div[5]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill Company Name with 'Initech' and Location with 'Remote', click 'Create Application' to submit the form so the page can be checked for success and the new entry.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[3]/form/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Initech')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[3]/form/div[3]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Remote')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/form/div[5]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        frame = context.pages[-1]\n        await frame.wait_for_timeout(1000)\n        assert await frame.locator(\"text=Company Name is required\").is_visible(), \"Expected validation message 'Company Name is required' to be visible\"\n        \n        # After fixing the error and submitting, verify success and the new entry\n        await frame.wait_for_timeout(1000)\n        await frame.wait_for_selector(\"text=Success\", timeout=5000)\n        assert await frame.locator(\"text=Success\").is_visible(), \"Expected 'Success' message after submission\"\n        await frame.wait_for_selector(\"text=Initech\", timeout=5000)\n        assert await frame.locator(\"text=Initech\").is_visible(), \"Expected 'Initech' to appear in the applications list\"\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/344854e8-2011-70ac-ebe1-5129fdf79642/1771175612610586//tmp/test_task/result.webm",
    "created": "2026-02-15T17:09:20.026Z",
    "modified": "2026-02-15T17:13:32.758Z"
  },
  {
    "projectId": "8cc6b0d0-5d58-453c-8d4b-add2a67214fe",
    "testId": "9e74b331-662a-4837-b8c1-596d56ee04db",
    "userId": "344854e8-2011-70ac-ebe1-5129fdf79642",
    "title": "TC006-Validation for missing Job Title",
    "description": "Verifies the form shows a validation error when Job Title is missing and submits successfully after Job Title is provided.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the New Application form by clicking the 'New Application' button.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div/header/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill Company Name with 'Hooli', clear Job Title (leave empty), set Date to '2026-02-12', set Location to 'San Francisco, CA', then click 'Create Application' to trigger the validation error.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Hooli')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('2026-02-12')\n        \n        # -> Clear the Job Title field (ensure it's empty) and submit the form to trigger the validation error ('Job Title is required'). Then verify the validation message appears.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[3]/form/div[1]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/form/div[5]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill Job Title with 'Backend Engineer' and Location with 'San Francisco, CA', then submit the form to complete the application submission step (click 'Create Application').\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[3]/form/div[1]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Backend Engineer')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[3]/form/div[3]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('San Francisco, CA')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/form/div[5]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/344854e8-2011-70ac-ebe1-5129fdf79642/1771175555434242//tmp/test_task/result.webm",
    "created": "2026-02-15T17:09:20.034Z",
    "modified": "2026-02-15T17:12:35.539Z"
  },
  {
    "projectId": "8cc6b0d0-5d58-453c-8d4b-add2a67214fe",
    "testId": "586f41c7-ecc3-4d5b-93cc-ae67631b4531",
    "userId": "344854e8-2011-70ac-ebe1-5129fdf79642",
    "title": "TC007-Validation for missing Status selection",
    "description": "Verifies the form shows a validation error when Status is not selected and submits successfully after selecting a Status.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'New Application' button to open the new application form.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div/header/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Ensure the new application form is open by clicking the 'New Application' button (again if necessary) so the form input fields become available.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div/header/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Type 'Stark Industries' into the Company Name field (use input index 355). Then fill Job Title (index 357) with 'Mobile Developer', Location (index 392) with 'Los Angeles, CA', Date Applied (index 388) with '2026-02-11', then click the Create Application / Submit button (index 402) without selecting Status to trigger validation.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Stark Industries')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Mobile Developer')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[3]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Los Angeles, CA')\n        \n        # -> Click the 'Create Application' / Submit button (index 402) to attempt submission without selecting Status and observe whether a 'Status is required' validation appears.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/form/div[5]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the New Application dialog to reset the form state, then re-open a fresh New Application form so the Status field can be tested (attempt to submit with Status unselected).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the New Application form, fill Company Name, Job Title, Location and Application Date, then click Create/Submit to trigger validation (expect 'Status is required').\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div/header/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the current New Application form fields (Company Name, Job Title, Location, Application Date) using the visible inputs, then click Create Application to attempt submission without changing the Status field.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[3]/form/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Stark Industries')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[3]/form/div[1]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Mobile Developer')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[3]/form/div[3]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Los Angeles, CA')\n        \n        # -> Click the 'Create Application' submit button (index 802) to submit the form (Status is already 'Applied'), then verify the UI shows success and that 'Stark Industries' appears in the list.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/form/div[5]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Submit the current form by clicking the Create Application button to complete the flow (status currently set to 'Applied'), then verify the results.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open a fresh New Application form so inputs are available (click 'New Application' button).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div/header/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the current New Application form with the requested values, then submit the form (Status is already 'Applied') so the flow completes and the results can be verified.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Stark Industries')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Mobile Developer')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('2026-02-11')\n        \n        # -> Click the Create Application button to submit the current form (Status already 'Applied'), then verify success and that 'Stark Industries' appears in the list.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/form/div[5]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Status combobox to attempt to clear/unset the Status (so the validation for missing Status can be tested). If the dropdown exposes a blank/default option it can be selected; otherwise inspect options after opening.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/form/div[2]/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill Location input (index 1282) with 'Los Angeles, CA', click Create Application (index 1292) to submit, then extract page content to verify 'Success' message and that 'Stark Industries' is visible in the applications list.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[3]/form/div[3]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Los Angeles, CA')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/form/div[5]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Success').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Expected a 'Success' confirmation after selecting a Status and submitting the application, but the success message did not appear. The submission likely did not complete or the new 'Stark Industries' entry was not created/displayed.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test run summary and final report:\n\n1) Goal attempted: Verify the form shows a \"Status is required\" validation when Status is not selected, then submit successfully after selecting a Status.\n\n2) What was done:\n- Navigated to /applications.\n- Opened the New Application form multiple times and filled Company Name='Stark Industries', Job Title='Mobile Developer', Date Applied='2026-02-11', Location='Los Angeles, CA'.\n- Attempted to submit with Status unselected to trigger validation.\n- Opened the Status combobox to look for a blank/unset option.\n- Filled missing Location when a Location-required validation appeared and submitted the form.\n\n3) Results / Findings:\n- \"Status is required\" validation: NOT reproduced. Reason: the Status control in the form is pre-selected as 'Applied' and the dropdown does not expose a blank/unset option, so submission without a selected Status cannot be performed in the current UI.\n- Submission after required fields filled: the application record for 'Stark Industries' appears in the applications list (entry found with Mobile Developer, Applied, Los Angeles, CA, Applied Feb 15, 2026). This indicates the submission saved the application.\n- Explicit textual \"Success\" confirmation: NOT found in the page content after submit.\n\n4) Conclusion:\n- The requested validation check (error when Status not selected) could not be completed because the UI always has a Status selected and offers no empty option.\n- The submission flow (with Status present) succeeded in creating an application entry visible in the list, but no explicit \"Success\" message was present in the page content to assert.\n\n5) Recommendation / next steps (optional):\n- If the test must assert a \"Status is required\" validation, the application code/UI must allow an unset/blank Status option or otherwise start with Status unset; then re-run the test.\n- If confirmation text is required, add or expose a success message in the UI to make that assertion reliable.\n\nBecause the core verification (validation for missing Status) could not be reproduced, the end result is reported as incomplete for that requirement.\n\nSummary of status: 'Stark Industries' found in the list; \"Status is required\" validation NOT reproduced; \"Success\" text NOT found.\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/344854e8-2011-70ac-ebe1-5129fdf79642/1771175774720798//tmp/test_task/result.webm",
    "created": "2026-02-15T17:09:20.040Z",
    "modified": "2026-02-15T17:16:14.889Z"
  },
  {
    "projectId": "8cc6b0d0-5d58-453c-8d4b-add2a67214fe",
    "testId": "a9a611c7-5a4a-4e22-aaf3-33a0fff7e198",
    "userId": "344854e8-2011-70ac-ebe1-5129fdf79642",
    "title": "TC008-Validation for missing Location",
    "description": "Verifies the form shows a validation error when Location is missing and allows submission after entering Location.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'New Application' (Add Application) button to open the new application form.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div/header/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Type 'Wayne Enterprises' into the Company Name field and continue filling the form through the first submit to trigger the validation error for missing Location.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Wayne Enterprises')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Data Analyst')\n        \n        # -> Fill the Application Date with 2026-02-09 and click 'Create Application' to trigger validation for missing Location.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[3]/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('2026-02-09')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/form/div[5]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the Location field with 'Gotham City' (input index 387) and submit the form by clicking 'Create Application' (button index 397).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[3]/form/div[3]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Gotham City')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/form/div[5]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        # -> Assert validation error is shown for missing Location after first submit\n        frame = context.pages[-1]\n        await frame.wait_for_selector(\"text=Location is required\", timeout=5000)\n        assert await frame.locator(\"text=Location is required\").is_visible(), \"Expected validation message 'Location is required' to be visible\"\n        \n        # -> After filling Location and submitting, assert success message and that the new application is visible\n        frame = context.pages[-1]\n        await frame.wait_for_selector(\"text=Success\", timeout=5000)\n        assert await frame.locator(\"text=Success\").is_visible(), \"Expected 'Success' message to be visible after submission\"\n        await frame.wait_for_selector(\"text=Wayne Enterprises\", timeout=5000)\n        assert await frame.locator(\"text=Wayne Enterprises\").is_visible(), \"Expected 'Wayne Enterprises' to be visible in the applications list\"\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/344854e8-2011-70ac-ebe1-5129fdf79642/1771175547883499//tmp/test_task/result.webm",
    "created": "2026-02-15T17:09:20.047Z",
    "modified": "2026-02-15T17:12:27.989Z"
  },
  {
    "projectId": "8cc6b0d0-5d58-453c-8d4b-add2a67214fe",
    "testId": "f7ed1ff1-be03-4dd2-acee-e54bc2b080c7",
    "userId": "344854e8-2011-70ac-ebe1-5129fdf79642",
    "title": "TC009-Validation for missing Application Date",
    "description": "Verifies the form shows a validation error when Application Date is missing and submits successfully after entering a date.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'New Application' button to open the application form.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div/header/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill 'Company Name' with 'Umbrella Corp'.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Umbrella Corp')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('DevOps Engineer')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[3]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Raccoon City')\n        \n        # -> Clear the 'Date Applied' field and submit the form to assert the 'Application Date is required' validation message appears.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[3]/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/form/div[5]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the 'New Application' form so the Application Date can be set and the form re-submitted.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div/header/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the 'Date Applied' field with '2026-02-08' and submit the form (click 'Create Application'). Then check for success and the new entry (done after page updates).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('2026-02-08')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[4]/form/div[5]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Umbrella Corp').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Expected the newly created application 'Umbrella Corp' to be visible after submitting the form with a valid Application Date, but the entry did not appear on the applications list\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test result summary:\n\n1) Validation when Application Date is missing: FAILED\n- Action: Cleared the Date Applied field and clicked 'Create Application'.\n- Observation: No validation text 'Application Date is required' appeared. Instead, the application was created and an 'Umbrella Corp' entry exists with a default/epoch date (Jan 1, 1970 in the list). This indicates the app accepted the form without the date instead of showing the expected validation error.\n\n2) Submit after entering a date: INCONCLUSIVE / NO SUCCESS TOAST\n- Action: Reopened the New Application modal, set Date Applied to 2026-02-08 and clicked 'Create Application'.\n- Observation: No visible success message was detected. The modal currently displays required-field errors for other fields (company/job/location) and appears reset to placeholders. However, the 'Umbrella Corp' entry is present in the applications list (created earlier when date was empty).\n\nEvidence from the page state:\n- Applications list contains an 'Umbrella Corp' entry (location: Raccoon City) with an application date shown as Jan 1, 1970 (epoch/default), Updated Feb 15. This shows a record was created despite the missing date.\n- Search for text 'Application Date is required' returned 'not found'.\n- No 'Success' toast or confirmation text was observed after the second submit.\n\nConclusion and recommendation:\n- The application does not enforce client-side validation for the Application Date (or server-side allowed empty date), which causes the test expectation to fail. The form allowed creation with an empty/cleared date.\n- If the expected behavior is to block submission and show 'Application Date is required', this is a bug in the frontend or backend validation logic. Suggested next steps: open an issue for the devs with reproduction steps and the evidence above; add an automated test asserting the presence of the validation message and that no entry is created when date is empty.\n\nTest result: success=false\n\nDetailed reproduction steps performed:\n1. Opened http://localhost:3000/applications\n2. Clicked 'New Application'\n3. Filled Company Name='Umbrella Corp', Job Title='DevOps Engineer', Status='Applied', Location='Raccoon City'\n4. Cleared Date Applied and clicked 'Create Application' -> no validation message; entry created with epoch date\n5. Reopened New Application modal, set Date Applied='2026-02-08', clicked 'Create Application' -> no success toast found; modal shows required-field messages for other fields\n6. Confirmed 'Umbrella Corp' visible in the list (created earlier)\n\nIf further verification is required (for example: re-run the test ensuring company/job/location fields are blank to reproduce the second submission path), specify next steps and the test can be continued.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/344854e8-2011-70ac-ebe1-5129fdf79642/1771175520314134//tmp/test_task/result.webm",
    "created": "2026-02-15T17:09:20.054Z",
    "modified": "2026-02-15T17:12:00.450Z"
  },
  {
    "projectId": "8cc6b0d0-5d58-453c-8d4b-add2a67214fe",
    "testId": "3096d491-5acd-453c-8cad-6a74a1209a0f",
    "userId": "344854e8-2011-70ac-ebe1-5129fdf79642",
    "title": "TC010-Filter applications by search term matching company name",
    "description": "Verifies that typing a company name keyword filters the list and clearing restores the full list.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Check that the text 'Applications' is visible on the page, then type 'Acme' into the search input to filter the list.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Acme')\n        \n        # -> Clear the search input (index 6) so the full list should be restored, then verify the input is empty and the two application cards reappear.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n        # -> Navigate to the applications page without the search query to reset filters, wait for the page to load, then extract page text to verify whether the search input is empty and whether application cards are displayed (or 'No applications found').\n        await page.goto(\"http://localhost:3000/applications\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Type 'Acme' into the search input (index 419), wait for the page to update, then extract visible text to determine whether the list is filtered. If filtered result is observed, then clear the input and verify full list is restored (will be next step after extraction).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Acme')\n        \n        # -> Clear the search input (index 419) to remove the search query and restore the full application list, then verify the input is empty and application cards appear.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n        # -> Clear the search input (element index 419) to remove the search query, wait for the page to update, then extract visible page text to confirm the header, the input value/placeholder, and whether application cards are displayed or 'No applications found' remains.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n        # -> Navigate to /applications (no query) to reset filters, wait for the page to load, then extract visible page text to verify header presence, search input state (empty/placeholder), and whether application cards are displayed (or 'No applications found').\n        await page.goto(\"http://localhost:3000/applications\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Type 'Acme' into the visible search input (index 782), wait for UI update, extract visible page text to confirm which application cards are shown. Then clear the input (index 782), wait, and extract page text to confirm the full list is restored.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Acme')\n        \n        # -> Clear the search input (index 782), wait for the page to update, then extract visible page text to confirm the input is empty (or placeholder visible) and the full list of applications is shown (or provide 'No applications found' if that remains).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n        # -> Focus the visible search input (index 782), clear its contents using keyboard select+delete, wait for the UI to update, then extract page text to verify whether the header is present, the search input is empty (or shows placeholder), and whether the full list of application cards is visible (or 'No applications found').\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Clear the visible search input (index 782), wait for the UI to update, then extract visible page text to verify header presence, the search input value/placeholder, and whether the full list of application cards is visible (or 'No applications found'). If full list is present and input empty, finish with success.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        # Assertions: verify header, filtered result, and cleared input\n        assert await page.locator(\"text=Applications\").count() > 0, \"Expected to find 'Applications' text on the page\"\n        assert await page.locator(\"text=Acme\").count() > 0, \"Expected to find 'Acme' visible after typing into the search input\"\n        input_el = page.locator('xpath=html/body/main/div/div/div[1]/div[1]/input').nth(0)\n        input_value = await input_el.input_value()\n        assert input_value == \"\", f\"Expected search input to be empty after clearing, got: '{input_value}'\"\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/344854e8-2011-70ac-ebe1-5129fdf79642/1771175850294399//tmp/test_task/result.webm",
    "created": "2026-02-15T17:09:20.061Z",
    "modified": "2026-02-15T17:17:30.469Z"
  },
  {
    "projectId": "8cc6b0d0-5d58-453c-8d4b-add2a67214fe",
    "testId": "cd2f7e08-ff67-45b5-acda-ca330e9864b8",
    "userId": "344854e8-2011-70ac-ebe1-5129fdf79642",
    "title": "TC011-Filter applications by search term matching job title",
    "description": "Verifies that typing a job title keyword filters the list and shows matching rows only.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Type 'Engineer' into the search input to filter the list and observe results.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Engineer')\n        \n        # -> Clear the search bar (set the search input to an empty string) to restore the full applications list.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Engineer').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Expected the applications list to show rows matching the job title 'Engineer' after typing 'Engineer' into the search bar, but the text 'Engineer' was not visible — the filter did not display matching job titles.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test summary and results:\n- Test goal: Verify typing a job-title keyword filters the applications list and shows only matching rows.\n- Steps executed:\n  1) Navigated to /applications. Initial state previously had application cards (earlier run showed 'Junior' and 'Senior').\n  2) Entered search term 'Engineer' into the search input (shadow input index 6). URL updated to /applications?search=Engineer.\n  3) Confirmed the search text is present/visible.\n  4) Observed page response: instead of showing matching application cards, the page displays the message 'No applications found'.\n  5) Cleared the search input (set to empty). Page still displays 'No applications found'.\n- Observed failures (objective statements):\n  • Filter did not return matching rows for the keyword 'Engineer' - page shows 'No applications found' rather than displaying matching application cards.\n  • Clearing the search input did not restore the full applications list; 'No applications found' remains visible.\n  • Current interactive state: search input exists at index 6 (placeholder 'Search companies or roles...'); the page contains the message 'No applications found'. The URL includes the query parameter search=Engineer.\n- Likely causes to investigate: missing/incorrect filter implementation, search query persisted in URL but not applied correctly to data, or rendering/state update failure after search/clear.\n- Recommendation next steps for developer/engineer: verify backend/filter logic, ensure the initial dataset is loaded when no filter applied, ensure clearing input clears URL/state and triggers list re-render, and add unit/e2e checks for both matching results and clear-to-restore behavior.\nResult: Test failed. The application did not behave as expected when filtering by keyword; clearing did not restore the list. Provide logs/screenshots and reproduce with dev tools to debug further.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/344854e8-2011-70ac-ebe1-5129fdf79642/1771175479370006//tmp/test_task/result.webm",
    "created": "2026-02-15T17:09:20.068Z",
    "modified": "2026-02-15T17:11:19.500Z"
  },
  {
    "projectId": "8cc6b0d0-5d58-453c-8d4b-add2a67214fe",
    "testId": "f808427b-1a4c-490e-bfa2-3796b32fa779",
    "userId": "344854e8-2011-70ac-ebe1-5129fdf79642",
    "title": "TC012-Search with no matches shows empty state and can be cleared",
    "description": "Verifies that a non-matching search term shows a no-results/empty state and clearing restores the list.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Type 'NonexistentCo' into the search input (index 6) to trigger a no-results state.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('NonexistentCo')\n        \n        # -> Clear the search input to restore the applications list, then verify the applications are visible again.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n        # -> Trigger a search submission/update after clearing the input so the applications list refreshes (click the search input (index 6) and press Enter).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Clear the search input (index 6) and submit the search (press Enter) so the applications list refreshes and verify the application cards reappear.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n        # -> Navigate to the applications page without the search query (http://localhost:3000/applications) to force the list to refresh, then verify application cards are visible.\n        await page.goto(\"http://localhost:3000/applications\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        # -> Final assertions according to the test plan\n        frame = context.pages[-1]\n        # Give the UI a moment to settle\n        await page.wait_for_timeout(1000)\n        # 1) Verify the applications list is visible by checking for a known job item\n        apps_item = frame.locator(\"text=Mobile Developer\").nth(0)\n        assert await apps_item.is_visible(), \"Applications list is not visible: 'Mobile Developer' not found\"\n        \n        # 2) Verify the no-results/empty state is shown for the non-matching search term\n        # (look for the exact text 'No results')\n        no_results = frame.locator(\"text=No results\")\n        await page.wait_for_timeout(500)\n        assert await no_results.is_visible(), \"Expected 'No results' message for non-matching search term\"\n        \n        # 3) Verify clearing the search restores the applications list (check for another known job item)\n        # Ensure final navigation/update has completed\n        await page.wait_for_timeout(1000)\n        frame = context.pages[-1]\n        restored_item = frame.locator(\"text=Frontend Engineer\").nth(0)\n        assert await restored_item.is_visible(), \"Applications list did not restore after clearing search: 'Frontend Engineer' not found\"\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/344854e8-2011-70ac-ebe1-5129fdf79642/1771175556126606//tmp/test_task/result.webm",
    "created": "2026-02-15T17:09:20.074Z",
    "modified": "2026-02-15T17:12:36.285Z"
  },
  {
    "projectId": "8cc6b0d0-5d58-453c-8d4b-add2a67214fe",
    "testId": "cbaf7ed1-e33c-437d-8a09-32bef83c3f43",
    "userId": "344854e8-2011-70ac-ebe1-5129fdf79642",
    "title": "TC013-Status filter dropdown filters to INTERVIEWING and can be cleared",
    "description": "Verifies that selecting a status narrows results and clearing returns to the full list.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'All Statuses' status filter dropdown to open the status options.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Select the 'Interview' option from the open status dropdown to apply the filter (click option index 363).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/div/div/div[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> 1) Extract visible application cards to verify currently visible cards and their statuses (confirm whether filter narrowed results). 2) Open status filter dropdown and select 'All Statuses' to clear filter. 3) Extract visible application cards again to verify the full list is restored. Then report results and stop.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Extract the currently visible application cards to confirm the filtered results (company/role, location, status), then click the 'All Statuses' option (index 542) to clear the filter, then extract the application cards again to verify the full list is restored.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Extract the currently visible application cards to confirm whether the full list (mixed statuses) is visible now, then open the 'All Statuses' dropdown.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> 1) Click the 'Interview' option (index 881) to apply the filter. 2) Extract visible application cards to verify only Interview items are shown. 3) Click 'All Statuses' (index 879) to clear the filter. 4) Extract visible cards again to verify the full list is restored.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/div/div/div[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/div/div/div[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the status filter dropdown so the 'All Statuses' option can be selected to clear the filter.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click 'All Statuses' to clear the status filter so the full applications list is restored (click option index 1014). After that, extract the visible application cards to verify the full list and then finish.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/div/div/div[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Extract the currently visible application cards to confirm whether the page is still filtered to INTERVIEW, then open the status filter dropdown so the 'All Statuses' option can be selected to clear the filter.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Interview' option (index 1451) to apply the Interview filter, then extract visible cards to confirm only Interview items are shown.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/div/div/div[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> 1) Extract the currently visible application cards to verify whether only 'Interview' items are shown (confirm filtered state). 2) Open the status filter dropdown so the 'All Statuses' option can be selected next.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Extract the currently visible application cards to confirm the filtered results show only 'Interview' items, then click 'All Statuses' to clear the filter, then extract again to verify the full list is restored.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/div/div/div[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the status filter dropdown so the 'Interview' option can be selected next.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Extract the currently visible application cards to confirm the full list is visible, then click the 'Interview' option (index 1999) to apply the Interview filter.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/div/div/div[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Extract the currently visible application cards to confirm the filtered results show only 'Interview' items, then open the status filter dropdown (click combobox) so the 'All Statuses' option can be selected.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click 'All Statuses' to clear the status filter, then extract the visible application cards to verify the full applications list is restored.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/div/div/div[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/344854e8-2011-70ac-ebe1-5129fdf79642/1771176092479933//tmp/test_task/result.webm",
    "created": "2026-02-15T17:09:20.081Z",
    "modified": "2026-02-15T17:21:32.594Z"
  },
  {
    "projectId": "8cc6b0d0-5d58-453c-8d4b-add2a67214fe",
    "testId": "00dfb64c-8d0f-4fa2-a8e6-a30461266cdc",
    "userId": "344854e8-2011-70ac-ebe1-5129fdf79642",
    "title": "TC014-Switching status filter from one value to another updates results",
    "description": "Verifies that changing the selected status updates the displayed applications accordingly.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the status filter dropdown (All Statuses) to open the status options menu so APPLIED can be selected.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Select 'APPLIED' from the status dropdown and verify the text 'APPLIED' is visible (and that the displayed applications update accordingly).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/div/div/div[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Select 'OFFER' from the open status list by clicking option index 680 so the page updates to show Offer applications, then verify the text 'OFFER' is visible and application cards update accordingly.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/div/div/div[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the status filter dropdown so the 'Offer' option can be re-selected (attempt to apply the Offer filter again).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/344854e8-2011-70ac-ebe1-5129fdf79642/1771175589383448//tmp/test_task/result.webm",
    "created": "2026-02-15T17:09:20.088Z",
    "modified": "2026-02-15T17:13:09.527Z"
  },
  {
    "projectId": "8cc6b0d0-5d58-453c-8d4b-add2a67214fe",
    "testId": "558f7415-b6af-4da1-b726-dec1f52fb5f6",
    "userId": "344854e8-2011-70ac-ebe1-5129fdf79642",
    "title": "TC015-Combine search and status filter then clear both",
    "description": "Verifies that search and status filtering can be used together and clearing both restores the unfiltered view.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Verify the applications list is visible by finding 'Vlexx' on the page, then type 'Acme' into the search input (index 6).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Acme')\n        \n        # -> Click the status filter dropdown to open status options (click element index 73).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Interview' option in the open status list to apply the INTERVIEWING status filter (use option element index 455).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/div/div/div[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Clear the search input (index 6) by setting it to an empty string.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n        # -> Open the status filter combobox (click element index 73) to reveal options so the status filter can be cleared (select All/clear).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'All Statuses' option to clear the status filter (select the option at index 579), then verify the applications list becomes visible.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/div/div/div[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Clear the search input value (empty) so the filters are fully cleared, then verify the applications list becomes visible.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/344854e8-2011-70ac-ebe1-5129fdf79642/1771175581317274//tmp/test_task/result.webm",
    "created": "2026-02-15T17:09:20.095Z",
    "modified": "2026-02-15T17:13:01.457Z"
  },
  {
    "projectId": "8cc6b0d0-5d58-453c-8d4b-add2a67214fe",
    "testId": "2bdab93d-b2ae-486e-9cd3-6dbac7eeba32",
    "userId": "344854e8-2011-70ac-ebe1-5129fdf79642",
    "title": "TC016-Whitespace-only search does not apply a filter",
    "description": "Verifies that entering only spaces does not filter results (or is treated as empty) and the list remains available.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Type three spaces into the search bar (input element index 6) to verify that entering only spaces does not filter results.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('   ')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n        # -> Clear the search input (index 6) by setting it to an empty string so the application list can be restored.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n        # -> Clear the search input (index 6) by setting it to an empty string so the application list can be restored.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n        # -> Clear the search input (index 6) by setting its value to an empty string so the applications list can be restored, then verify the search bar is empty.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n        # -> Clear the search input (index 6) by setting it to an empty string (use clear=true) to restore the applications list, then verify the search bar is empty.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n        # -> Clear the search input (index 6) by setting it to an empty string (use clear=true) to restore the applications list.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n        # -> Clear the search input (index 6) by setting it to an empty string with clear=true to restore the applications list.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n        # -> Clear the search input (index 6) by setting its value to an empty string (use clear=true) to restore the applications list and allow verifying the search bar is empty.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n        # -> Clear the search input (index 6) by setting its value to an empty string (use clear=true) so the applications list can be restored, then verify the search bar is empty.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n        # -> Clear the search input (index 6) by setting it to an empty string (use clear=true) to restore the applications list and then verify the search bar is empty.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n        # -> Clear the search input (index 6) by setting its value to an empty string (use clear=true) to restore the applications list and allow verifying the search bar is empty.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n        # -> Clear the search input (index 6) by setting its value to an empty string (use clear=true) to restore the applications list.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n        # -> Clear the search input (index 6) by setting it to an empty string (clear=true) to restore the applications list, then extract the visible application cards to confirm the list and check for the 'No applications found' message.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n        # -> Clear the search input (index 6) by setting it to an empty string (clear=true), wait for the page to update, then extract the visible application cards and report whether 'No applications found' is present or the applications list is visible.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n        # -> Clear the search input (index 6) by setting it to an empty string, wait for the page to update, then extract the visible application cards and report whether 'No applications found' is present or the applications list is visible.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n        # -> Clear the search input correctly and submit the cleared value so the page updates, then extract the visible application cards and report whether 'No applications found' is still present or the applications list is visible.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div/div/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        ```\n        try:\n            await expect(frame.locator('text=Applications').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: verifying that entering only spaces into the search bar does not filter results — expected the applications list ('Applications') to remain visible but it was not found\")\n        ```\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Verification summary:\n\nGoal: Confirm that entering only spaces into the search bar is treated as empty/ignored and the applications list remains visible.\n\nWhat was observed:\n- Initial state: Applications list visible and extracted items: 'Vlexx — Junior', 'Test — Senior'.\n- Action: Entered three spaces into the search input (index 6).\n- Result: Page showed \"No applications found\" and the URL contains search=+++. The application treated spaces as a real query instead of trimming them.\n- Attempts to recover: Several attempts to clear the input and submit an empty value (clicked input, typed empty string, pressed Enter) were performed but did not restore the applications list.\n\nConclusion:\n- The application does NOT treat an input of only spaces as empty; it treats spaces as a valid query and filters results (observed behavior is a failure against the expectation).\n\nRecommendation:\n- Trim whitespace from the search input on the client side (or on the server/filtering side) so that queries consisting only of whitespace are treated as empty and the full list remains visible.\n\nTest outcome: failed (behavior not as expected).",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/344854e8-2011-70ac-ebe1-5129fdf79642/177117574789523//tmp/test_task/result.webm",
    "created": "2026-02-15T17:09:20.101Z",
    "modified": "2026-02-15T17:15:48.043Z"
  },
  {
    "projectId": "8cc6b0d0-5d58-453c-8d4b-add2a67214fe",
    "testId": "adcaf606-d975-4ded-99e8-fc82fe049056",
    "userId": "344854e8-2011-70ac-ebe1-5129fdf79642",
    "title": "TC017-Delete an application after confirming in the dialog",
    "description": "Verifies a user can delete an application from the list after confirming and the item disappears from the list with a visible success indication.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the Delete button for the first application (Vlexx) to open the confirmation dialog.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div/div/div[2]/div[1]/div[3]/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the confirmation button in the dialog (the 'Delete' button) to confirm deletion of the Vlexx application.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the Delete button for the first application ('Test') to open the confirmation dialog (element index 176).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div/div/div[2]/div/div[3]/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the confirmation 'Delete' button in the open dialog to confirm deletion of the 'Test' application (index 462).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the open delete dialog, then search the page for the application name 'Test' to verify whether it was removed (or still present).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the Delete button for the first visible application (Stark Industries) to open the confirmation dialog.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div/div/div[2]/div[1]/div[3]/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the confirmation 'Delete' button in the open dialog for 'Stark Industries' (element index 819) to attempt deletion, then verify success message and that the item is removed.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        ```\n        try:\n            await expect(frame.locator('text=Deleted').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test attempted to delete an application and expected a visible 'Deleted' success message after confirming deletion, but the success message did not appear — the application may not have been removed or the UI failed to show the confirmation\")\n        ```\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test summary and result:\n\n- Steps executed:\n  1) Navigated to /applications and confirmed page and job list visible.\n  2) Attempted to delete three applications by opening each application's Delete dialog and clicking the confirmation Delete button for: Vlexx, Test, and Stark Industries.\n\n- Observed behavior:\n  - Each confirmation dialog opened and the 'Delete' confirmation button was clicked successfully.\n  - No visible success message 'Deleted' appeared after any deletion attempt.\n  - Applications previously targeted (Vlexx, Test) remained visible in the application list after confirmation clicks; the UI did not remove them.\n  - Current state: dialog for 'Stark Industries' was open and confirmed; still no success indication or removal.\n\n- Conclusion: Deletion flow failed to produce the expected result. The user-visible requirements (confirmation acknowledgement 'Deleted' and removal of the item from the list) were not met. Set success=false.\n\n- Suggested next troubleshooting steps:\n  1) Check browser devtools Network tab during a deletion to confirm the DELETE request is sent and the server responds with success (200/204). Capture request/response payload and status.\n  2) Check browser console for JavaScript errors that may prevent state update after a successful server response.\n  3) Confirm backend is running and the API endpoint for deleting applications is reachable and functioning.\n  4) If the API returns success but UI still doesn't remove the item, inspect front-end state management (e.g., ensure the list is refreshed or item removed from local state after success).\n  5) As a workaround in tests, consider reloading the list after deletion (page refresh) to determine if deletion actually completed on the server.\n\nIf further automated checks are desired, provide permission to: 1) capture network logs during deletion attempts, 2) attempt deletion again and then reload the list to confirm server-side removal, or 3) run the same scenario with network inspection enabled.\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/344854e8-2011-70ac-ebe1-5129fdf79642/1771175558310095//tmp/test_task/result.webm",
    "created": "2026-02-15T17:09:20.108Z",
    "modified": "2026-02-15T17:12:38.443Z"
  },
  {
    "projectId": "8cc6b0d0-5d58-453c-8d4b-add2a67214fe",
    "testId": "4b4ef412-dda6-456e-86ad-60d52d2ec936",
    "userId": "344854e8-2011-70ac-ebe1-5129fdf79642",
    "title": "TC018-Cancel deletion from the confirmation dialog",
    "description": "Verifies canceling the delete confirmation keeps the application in the list and does not show a deletion success message.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Delete' button for the first application (Vlexx) to open the delete confirmation dialog.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div/div/div[2]/div[1]/div[3]/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Cancel' button in the delete confirmation dialog to close it.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/344854e8-2011-70ac-ebe1-5129fdf79642/17711754411101//tmp/test_task/result.webm",
    "created": "2026-02-15T17:09:20.115Z",
    "modified": "2026-02-15T17:10:41.273Z"
  },
  {
    "projectId": "8cc6b0d0-5d58-453c-8d4b-add2a67214fe",
    "testId": "b260f35d-4caa-40bf-b122-db11ebb9c2d8",
    "userId": "344854e8-2011-70ac-ebe1-5129fdf79642",
    "title": "TC019-Dismiss delete confirmation dialog with Escape key",
    "description": "Verifies the confirmation dialog can be dismissed via keyboard and the application remains listed.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the Delete button for the first application (Vlexx) to open the confirmation dialog.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div/div/div[2]/div[1]/div[3]/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        # -> Verify the delete confirmation dialog is visible\n        await frame.get_by_role(\"dialog\").wait_for(state=\"visible\", timeout=5000)\n        \n        # -> Dismiss the dialog with Escape\n        await page.keyboard.press(\"Escape\")\n        \n        # -> Verify the delete confirmation dialog is not visible\n        await frame.get_by_role(\"dialog\").wait_for(state=\"hidden\", timeout=5000)\n        \n        # -> Verify the first application row (Junior Vlexx) is still visible\n        await frame.get_by_text(\"Junior Vlexx\").wait_for(state=\"visible\", timeout=5000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/344854e8-2011-70ac-ebe1-5129fdf79642/1771175438863311//tmp/test_task/result.webm",
    "created": "2026-02-15T17:09:20.122Z",
    "modified": "2026-02-15T17:10:38.999Z"
  },
  {
    "projectId": "8cc6b0d0-5d58-453c-8d4b-add2a67214fe",
    "testId": "aa4071de-0f81-4448-a4b1-e7d29d568fbe",
    "userId": "344854e8-2011-70ac-ebe1-5129fdf79642",
    "title": "TC020-Delete confirmation dialog shows the expected prompt content",
    "description": "Verifies the delete confirmation dialog displays a clear prompt before the user confirms deletion.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the Delete button for the first application (Vlexx) to open the confirmation dialog so the dialog content can be verified.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div/div/div[2]/div[1]/div[3]/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        # -> Assertions: verify job applications list is visible\n        await frame.wait_for_selector(\"text=Job Applications\", timeout=5000)\n        assert await frame.locator(\"text=Job Applications\").is_visible()\n        \n        # -> Verify confirmation dialog text is visible\n        await frame.wait_for_selector(\"text=Are you sure\", timeout=5000)\n        assert await frame.locator(\"text=Are you sure\").is_visible()\n        \n        # -> Verify Confirm (Delete) and Cancel buttons are visible in the confirmation dialog\n        await frame.wait_for_selector(\"text=Cancel\", timeout=5000)\n        assert await frame.locator(\"text=Cancel\").is_visible(), \"Cancel button not visible in delete confirmation dialog\"\n        await frame.wait_for_selector(\"text=Delete\", timeout=5000)\n        assert await frame.locator(\"text=Delete\").is_visible(), \"Confirm/Delete button not visible in delete confirmation dialog\"\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/344854e8-2011-70ac-ebe1-5129fdf79642/1771175432541631//tmp/test_task/result.webm",
    "created": "2026-02-15T17:09:20.129Z",
    "modified": "2026-02-15T17:10:32.650Z"
  },
  {
    "projectId": "8cc6b0d0-5d58-453c-8d4b-add2a67214fe",
    "testId": "b65657bd-d5bf-406b-9304-e051a428ab92",
    "userId": "344854e8-2011-70ac-ebe1-5129fdf79642",
    "title": "TC021-Delete button is available for an application row in the list",
    "description": "Verifies each application row provides an in-list delete action to start the deletion flow.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        from playwright.async_api import expect\n        \n        # Verify the job applications list/heading is visible\n        await expect(page.locator(\"text=Job Applications\")).to_be_visible(timeout=5000)\n        # Verify the first application row is visible\n        first_row = page.get_by_role(\"listitem\").nth(0)\n        await expect(first_row).to_be_visible(timeout=5000)\n        # Verify the \"Delete\" action is visible on the first application row\n        await expect(first_row.locator(\"text=Delete\")).to_be_visible(timeout=5000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Low",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/344854e8-2011-70ac-ebe1-5129fdf79642/1771175442660079//tmp/test_task/result.webm",
    "created": "2026-02-15T17:09:20.136Z",
    "modified": "2026-02-15T17:10:42.769Z"
  },
  {
    "projectId": "8cc6b0d0-5d58-453c-8d4b-add2a67214fe",
    "testId": "dc094273-c408-4ba7-b604-b8c4b9777fa8",
    "userId": "344854e8-2011-70ac-ebe1-5129fdf79642",
    "title": "TC022-Confirm deletion closes the dialog and returns focus to the list view",
    "description": "Verifies that after confirming deletion, the confirmation dialog is no longer shown and the user is back on the list view.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Verify element 'job applications list' is visible by extracting the application card/company names from the page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div/div/div[2]/div[1]/div[3]/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Delete' (confirm) button inside the confirmation dialog to confirm deletion.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[4]/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        ```\n        try:\n            await expect(frame.locator('text=Job Applications List').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: After confirming deletion the confirmation dialog should have closed and the job applications list should be visible again, but the list did not appear (the dialog may still be present or navigation back to the list failed)\")\n        ```\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test result: FAILED. Objective check: After clicking Confirm/Delete, the delete confirmation dialog is still visible. Evidence: DOM contains a role=dialog element with data-state=open and the dialog text 'Delete Application' and 'Vlexx'. Current application cards visible on the page (pre-deletion state): - 'Junior' — Vlexx - 'Senior' — Test Because the confirmation dialog was not dismissed, the test cannot verify that the application was removed or that the list view was returned to. Next recommended actions (not executed): click the Delete/Confirm button again, click the dialog Close or Cancel to dismiss, or refresh the page and re-run the verification. Stopping now and reporting failure.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/344854e8-2011-70ac-ebe1-5129fdf79642/1771175454752797//tmp/test_task/result.webm",
    "created": "2026-02-15T17:09:20.142Z",
    "modified": "2026-02-15T17:10:54.883Z"
  }
]
